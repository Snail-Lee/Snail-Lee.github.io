{"pages":[],"posts":[{"title":"我的博客正式开通啦！","text":"前言折腾了两天，心里面一直心心念念的个人网站今天总算了走近了一点点。其实，前几天有些冲动斥资买了域名、买了服务器；花了几个小时在网上研究怎么搭网站。结果到处碰壁，为了贪图便宜，域名和服务器都是入手国外代理商。于是有了各种不适，境外服务器虽然不需要备案，但慢的要死。域名也虽然是godaddy这种国际大商购得，但是DNS解析真是让人抓狂。即使上了DNSpod,最后还是死在了域名服务器的更改，这让我后来用GitHub绑定域名时候总是不能实现跳转。作为一个前端入门小学生，这个小烦躁实属难受。不过我知道，很多事情是可以解决的，只是我的水平太低，步子迈的太大容易出事，慢些走，才能走得踏实，不会错过路边的风景。 过程利用 GitHub page 来搭一个静态博客首先需要做以下几个准备： 下载 Node.js （下载完成后需要进行环境配置） 下载 git 注册 GitHub 账号 剩下的就可以参考 hexo 官方文档（ https://hexo.bootcss.com/ ） 进行下一步的操作。具体从开始到成果实现 github page 的部署，以及后续修改各种配置以满足自己的需求，网上有很多图文教程和视频教程，不管是 hexo+github 还是 hexo+coding , 不管是macOS 、win 还是 Linux，基本上都能找到对应的详细操作。 总体搞下来，其实不是特别难。也就固定的几个步骤，固定的几条命令，我一开始出了很多问题，第一天搞了一白天，最后部署的时候总是有几个文件出错，于是晚上睡觉之前把所有的都推倒，卸载nodejs，卸载git，卸载hexo ······ 第二天按照步骤又重新来了一遍，很快，因为很多都变得熟悉了。也很顺利，因为有了第一天踩坑的经验了。最起码在和别人炫耀博客的时候不用担心答不上来怎么实现的尴尬了。 总结有时候看着别人的教程，一次性弄好也许并不是值得庆幸的一件事，程序员能力的提升就在于一个又一个的bug，尤其是像我这种小学生，只有不断地试错，即使是一个MySQL的安装、一个tomcat的配置 ······ ，我们第一次接触一个新东西时，为了追求高效，总是吃别人嚼过的馒头，这是尝不到甜头的。吃馒头的时候想想馒头是怎么做出来的，小麦是怎么产的。即使在别人看来有些幼稚，但我们要承认自己的无知，勤学好问。这大概也是我认为程序员的核心是他的学习能力而不是技术水平的原因吧。 和很多IT学者一样，我也想做一个计算机大神。于是就有了先实现前端大神的目标；于是又有了先实现前端项目的目标；于是我开始学习基础三剑客、学习Ajax， 学习vue、react ······ 路很长，但我知道要去哪。 这是我的第一篇博客，希望每一位学习计算机的人都能成为一位优秀的程序员。","link":"/2020/08/30/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%BC%80%E9%80%9A%E5%95%A6%EF%BC%81/"},{"title":"什么是web?","text":"1. 什么是web?20世纪60年代末期，美国军方开发了一个名为 ARPANET 的通信网络。这可以认为是 Web 的先驱，因为它基于分组交换（packet switching）进行工作，并且首次实现了TCP/IP协议族（TCP/IP protocol suite) 。这两种技术构成了互联网基础设施的基础。 1980 年，Tim Berners-Lee （通常称之为 TimBL ）写了一个叫 ENQUIRE 的笔记本程序，这个程序实现了不同节点之间链接的概念。 到 1989 年， TimBL 在 CERN 撰写了《Information Management: A Proposal》和 《HyperText》 ； 这两个出版物共同为 Web 将如何工作做了铺垫。两个出版物获得了极大的关注，这也极大地推动他继续前进，并创建了一个全球超文本系统。 到 1990 年底，TimBL 已经创建了运行第一个版本的 Web 所需的所有东西—— HTTP、HTML ，名为 WorldWideWeb 的第一个 Web 浏览器，一个 HTTP 服务器和一些用于查看的网页。 在随后的几年中，随着多个浏览器的发布，数以千计 Web 服务器的建立，上百万网页的生成， Web 爆发式发展。 最后在1994年，TimBL建立了万维网联盟（World Wide Web Consortium ，W3C），该组织汇集了来自许多不同技术公司的代表，共同制定 Web 技术规范。随后其他的技术像 CSS 和 JavaScript 出现了，这也就形成了我们现在所了解的 Web 。 2. web是如何工作的？首先，我们先简单了解一下客户端和服务器： 连接到互联网的计算机被称作客户端和服务器。下面是一个简单描述它们如何交互的图表： 客户端是典型的Web用户入网设备（比如，你连接了Wi-Fi的电脑，或接入移动网络的手机）和设备上可联网的软件（通常使用像 Firefox 和 Chrome的浏览器）。 服务器是存储网页，站点和应用的计算机。当一个客户端设备想要获取一个网页时，一份网页的拷贝将从服务器上下载到客户端机器上来在用户浏览器上显示。 举个例子：如果你想去商店买东西。现在假设 Web 就是一条路。路的一端是客户端，就像你的家。另一端则是服务器，就像你想去的商店。 除了客户端和服务器，我们还需要了解： 网络连接: 允许你在互联网上发送和接受数据。基本上和你家到商店的街道差不多。 TCP/IP: 传输控制协议和因特网互连协议是定义数据如何传输的通信协议。这就像你去商店购物所使用的交通方式，比如汽车或自行车（或是你能想到的其他可能）。 DNS: 域名系统服务器像是一本网站通讯录。当你在浏览器内输入一个网址时，浏览器获取网页之前将会查看域名系统。浏览器需要找到存放你想要的网页的服务器，才能发送 HTTP 请求到正确的地方。就像你要知道商店的地址才能到达那。 HTTP: 超文本传输协议是一个定义客户端和服务器间交流的语言的协议（protocol）。就像你下订单时所说的话一样。 组成文件 一个网页由许多文件组成，就像商店里不同的商品一样。这些文件有两种类型： 代码 : 网页大体由 HTML、CSS、JavaScript组成，不过你会在后面看到不同的技术。 资源 : 这是其他组成网页的东西的集合，比如图像、音乐、视频、Word文档、PDF文件。 当我们浏览网页的时候，到底发生了什么呢？ 当你在浏览器里输入一个网址时（在我们的例子里就是走向商店的路上时）： 浏览器在域名系统（DNS）服务器上找出存放网页的服务器的实际地址（找出商店的位置）。 浏览器发送 HTTP 请求信息到服务器来请拷贝一份网页到客户端（你走到商店并下订单）。这条消息，包括其他所有在客户端和服务器之间传递的数据都是通过互联网使用 TCP/IP 协议传输的。 服务器同意客户端的请求后，会返回一个“200”信息，意味着“你可以查看这个网页，给你～”，然后开始将网页的文件以数据包的形式传输到浏览器（商店给你商品，你将商品带回家）。 浏览器将数据包聚集成完整的网页然后将网页呈现给你（商品到了你家）。","link":"/2021/01/15/%E4%BB%80%E4%B9%88%E6%98%AFweb/"},{"title":"微信小程序开发获取用户地理位置","text":"1、获取用户当前地理位置1.1 配置app.json在小程序开发中，真正需要使用授权接口时，才向用户发起授权申请。如果需要获取用户当前地理位置，需要在授权申请中说明清楚要使用该功能的理由，需要授权 scope.userLocation、scope.userLocationBackground 时必须配置地理位置用途说明。 参考官方文档，在app.json文件中添加如下示例代码： 12345678{ &quot;pages&quot;: [&quot;pages/index/index&quot;], &quot;permission&quot;: { &quot;scope.userLocation&quot;: { &quot;desc&quot;: &quot;你的位置信息将用于小程序位置接口的效果展示&quot; // 高速公路行驶持续后台定位 } }} 1.2 调用函数进行请求json文件配置好之后，就可以在需要发起用户地理位置请求的页面文件中调用相关函数了。根据实际需求选择小程序提供的API：wx.getLocation(Object object) ，文档说明 12345678910wx.getLocation({ type: 'wgs84', success (res) { const latitude = res.latitude //获取经度 const longitude = res.longitude //获取维度 const speed = res.speed //获取速度 const accuracy = res.accuracy //获取精度 const altitude = res.altitude //获取高度 }}) 由于wx.getLocation(Object object)只能获取到经纬度数据，所以我们可以利用腾讯位置服务来进行逆地址解析，从而得到当前位置的具体省市县等详细地区信息。 2、腾讯位置服务应用2.1 注册认证账号并配置key值注册 -&gt; 绑定开发者信息 -&gt; key值配置 -&gt; 程序开发 key值配置的时候要注意信息填写 最后一项 webServiceAPI选择授权IP之后留空即可，不然在请求时出现返回签名验证失败。已工单询问（具体答复为：目前小程序JavascriptSDK不支持签名，目前的解决办法是改为授权IP，然后配置框留空） 2.2 利用其提供的 JavaScript SDK 实现开发根据腾讯位置服务API提供的小程序SDK使用文档进行开发： 申请开发者密钥（key）：申请密钥 开通webserviceAPI服务：控制台 -&gt; key管理 -&gt; 设置（使用该功能的key）-&gt; 勾选webserviceAPI -&gt; 保存 (小程序SDK需要用到webserviceAPI的部分服务，所以使用该功能的KEY需要具备相应的权限) 下载微信小程序JavaScriptSDK，微信小程序JavaScriptSDK v1.1 JavaScriptSDK v1.2 安全域名设置，在小程序管理后台 -&gt; 开发 -&gt; 开发管理 -&gt; 开发设置 -&gt; “服务器域名” 中设置request合法域名，添加https://apis.map.qq.com 小程序示例 123456789101112131415161718192021222324252627// 引入SDK核心类，js文件根据自己业务，位置可自行放置var QQMapWX = require('../../libs/qqmap-wx-jssdk.js');var qqmapsdk;Page({ onLoad: function () { // 实例化API核心类 qqmapsdk = new QQMapWX({ key: '申请的key' }); }, onShow: function () { // 调用接口 qqmapsdk.search({ keyword: '酒店', success: function (res) { console.log(res); }, fail: function (res) { console.log(res); }, complete: function (res) { console.log(res); } }); }}) 使用reverseGeocoder(options:Object) 接口进行逆地址解析 官方示例： 12345678910111213141516&lt;!--地图容器--&gt;&lt;!--longitude及latitude为设置为调转到指定坐标位置，默认不显示--&gt;&lt;map id=&quot;myMap&quot; markers=&quot;{{markers}}&quot; style=&quot;width:100%;height:300px;&quot; longitude=&quot;{{poi.longitude}}&quot; latitude=&quot;{{poi.latitude}}&quot; scale='16' show-location&gt;&lt;/map&gt;&lt;!--form表单--&gt;&lt;form bindsubmit=&quot;formSubmit&quot;&gt; &lt;!--地址输入框,例：39.984060,116.307520--&gt; &lt;input style=&quot;border:1px solid #000;&quot; name=&quot;reverseGeo&quot;&gt;&lt;/input&gt; &lt;!--提交表单按钮--&gt; &lt;button form-type=&quot;submit&quot;&gt;逆地址解析&lt;/button&gt;&lt;/form&gt;&lt;view&gt;当前位置为：{{markers[0].title}}&lt;/view&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 引入SDK核心类var QQMapWX = require('xxx/qqmap-wx.js'); // 实例化API核心类var qqmapsdk = new QQMapWX({ key: '开发密钥（key）' // 必填}); //在Page({})中使用下列代码//触发表单提交事件，调用接口formSubmit(e) { var _this = this; qqmapsdk.reverseGeocoder({ //位置坐标，默认获取当前位置，非必须参数 /** * //Object格式 location: { latitude: 39.984060, longitude: 116.307520 }, */ /** * //String格式 location: '39.984060,116.307520', */ location: e.detail.value.reverseGeo || '', //获取表单传入的位置坐标,不填默认当前位置,示例为string格式 //get_poi: 1, //是否返回周边POI列表：1.返回；0不返回(默认),非必须参数 success: function(res) {//成功后的回调 console.log(res); var res = res.result; var mks = []; /** * 当get_poi为1时，检索当前位置或者location周边poi数据并在地图显示，可根据需求是否使用 * for (var i = 0; i &lt; result.pois.length; i++) { mks.push({ // 获取返回结果，放到mks数组中 title: result.pois[i].title, id: result.pois[i].id, latitude: result.pois[i].location.lat, longitude: result.pois[i].location.lng, iconPath: './resources/placeholder.png', //图标路径 width: 20, height: 20 }) } * **/ //当get_poi为0时或者为不填默认值时，检索目标位置，按需使用 mks.push({ // 获取返回结果，放到mks数组中 title: res.address, id: 0, latitude: res.location.lat, longitude: res.location.lng, iconPath: './resources/placeholder.png',//图标路径 width: 20, height: 20, callout: { //在markers上展示地址名称，根据需求是否需要 content: res.address, color: '#000', display: 'ALWAYS' } }); _this.setData({ //设置markers属性和地图位置poi，将结果在地图展示 markers: mks, poi: { latitude: res.location.lat, longitude: res.location.lng } }); }, fail: function(error) { console.error(error); }, complete: function(res) { console.log(res); } })} 最后根据需要展示获取到的数据即可。","link":"/2021/01/30/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE/"}],"tags":[{"name":"成长日记","slug":"成长日记","link":"/tags/%E6%88%90%E9%95%BF%E6%97%A5%E8%AE%B0/"},{"name":"前端入门","slug":"前端入门","link":"/tags/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/"},{"name":"小程序开发","slug":"小程序开发","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"}],"categories":[{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"}]}